

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>RoMa: A lightweight library to deal with 3D rotations in PyTorch. &mdash; RoMa documentation 1.1.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> RoMa documentation
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#main-features">Main features</a><ul>
<li><a class="reference internal" href="#supported-rotation-representations">Supported rotation representations</a></li>
<li><a class="reference internal" href="#mappings-between-rotation-representations">Mappings between rotation representations</a></li>
<li><a class="reference internal" href="#mappings-from-euclidean-to-3d-rotation-space">Mappings from Euclidean to 3D rotation space</a></li>
<li><a class="reference internal" href="#support-for-an-arbitrary-number-of-batch-dimensions">Support for an arbitrary number of batch dimensions</a></li>
<li><a class="reference internal" href="#quaternion-operations">Quaternion operations</a></li>
<li><a class="reference internal" href="#rotation-composition-and-inverse">Rotation composition and inverse</a></li>
<li><a class="reference internal" href="#rotation-metrics">Rotation metrics</a></li>
<li><a class="reference internal" href="#weighted-rotation-averaging">Weighted rotation averaging</a></li>
<li><a class="reference internal" href="#spherical-linear-interpolation-slerp">Spherical linear interpolation (SLERP)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-a-new-library">Why a new library?</a></li>
<li><a class="reference internal" href="#api-documentation">API Documentation</a><ul>
<li><a class="reference internal" href="#module-roma.mappings">Mappings</a></li>
<li><a class="reference internal" href="#module-roma.utils">Utils</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced">Advanced</a><ul>
<li><a class="reference internal" href="#running-unit-tests">Running unit tests</a></li>
<li><a class="reference internal" href="#building-sphinx-documentation">Building Sphinx documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#license">License</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#changelog">Changelog</a></li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">RoMa documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>RoMa: A lightweight library to deal with 3D rotations in PyTorch.</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch">
<h1><a class="toc-backref" href="#id2">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a><a class="headerlink" href="#roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch" title="Permalink to this headline">¶</a></h1>
<p><em>RoMa</em> (which stands for Rotation Manipulation) provides differentiable mappings between 3D rotation representations, mappings from Euclidean to rotation space, and various utilities related to rotations.
It is implemented in PyTorch and aims to be an easy-to-use and reasonably efficient toolbox for Machine Learning and gradient-based optimization.</p>
<div class="section" id="installation">
<h2><a class="toc-backref" href="#id3">Installation</a><a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The easiest way to install <em>RoMa</em> consists in using pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">roma</span>
</pre></div>
</div>
<p>We also recommend installing <a class="reference external" href="https://github.com/KinglittleQ/torch-batch-svd">torch-batch-svd</a>
to achieve significant speed-up with <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a> on a CUDA GPU (see section <a class="reference internal" href="#why-a-new-library"><span class="std std-ref">Why a new library?</span></a>).</p>
<p>Alternatively one can install <em>RoMa</em> directly from source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">naver</span><span class="o">/</span><span class="n">roma</span>
</pre></div>
</div>
<p>or include the source repository (<a class="reference external" href="https://github.com/naver/roma">https://github.com/naver/roma</a>) as a Git submodule.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch" id="id2">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a></p>
<ul>
<li><p><a class="reference internal" href="#installation" id="id3">Installation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#main-features" id="id4">Main features</a></p>
<ul>
<li><p><a class="reference internal" href="#supported-rotation-representations" id="id5">Supported rotation representations</a></p></li>
<li><p><a class="reference internal" href="#mappings-between-rotation-representations" id="id6">Mappings between rotation representations</a></p></li>
<li><p><a class="reference internal" href="#mappings-from-euclidean-to-3d-rotation-space" id="id7">Mappings from Euclidean to 3D rotation space</a></p></li>
<li><p><a class="reference internal" href="#support-for-an-arbitrary-number-of-batch-dimensions" id="id8">Support for an arbitrary number of batch dimensions</a></p></li>
<li><p><a class="reference internal" href="#quaternion-operations" id="id9">Quaternion operations</a></p></li>
<li><p><a class="reference internal" href="#rotation-composition-and-inverse" id="id10">Rotation composition and inverse</a></p></li>
<li><p><a class="reference internal" href="#rotation-metrics" id="id11">Rotation metrics</a></p></li>
<li><p><a class="reference internal" href="#weighted-rotation-averaging" id="id12">Weighted rotation averaging</a></p></li>
<li><p><a class="reference internal" href="#spherical-linear-interpolation-slerp" id="id13">Spherical linear interpolation (SLERP)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#why-a-new-library" id="id14">Why a new library?</a></p></li>
<li><p><a class="reference internal" href="#api-documentation" id="id15">API Documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#module-roma.mappings" id="id16">Mappings</a></p></li>
<li><p><a class="reference internal" href="#module-roma.utils" id="id17">Utils</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced" id="id18">Advanced</a></p>
<ul>
<li><p><a class="reference internal" href="#running-unit-tests" id="id19">Running unit tests</a></p></li>
<li><p><a class="reference internal" href="#building-sphinx-documentation" id="id20">Building Sphinx documentation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#license" id="id21">License</a></p></li>
<li><p><a class="reference internal" href="#references" id="id22">References</a></p></li>
<li><p><a class="reference internal" href="#changelog" id="id23">Changelog</a></p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="main-features">
<h1><a class="toc-backref" href="#id4">Main features</a><a class="headerlink" href="#main-features" title="Permalink to this headline">¶</a></h1>
<div class="section" id="supported-rotation-representations">
<h2><a class="toc-backref" href="#id5">Supported rotation representations</a><a class="headerlink" href="#supported-rotation-representations" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>Rotation vector (rotvec)</dt><dd><ul class="simple">
<li><p>Encoded using a …x3 tensor.</p></li>
<li><p>3D vector <em>angle</em> * <em>axis</em> represents a rotation of angle <em>angle</em> (expressed in radians) around a unit 3D <em>axis</em>.</p></li>
</ul>
</dd>
<dt>Unit quaternion (unitquat)</dt><dd><ul class="simple">
<li><p>Encoded as …x4 tensor.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>We use XYZW quaternion convention, <em>i.e.</em> components of quaternion <span class="math notranslate nohighlight">\(x i + y j + z k + w\)</span>
are represented by the 4D vector <span class="math notranslate nohighlight">\((x,y,z,w)\)</span>.</p></li>
<li><p>We assume unit quaternions to be of unit length, and do not perform implicit normalization.</p></li>
</ul>
</div>
</dd>
<dt>Rotation matrix (rotmat)</dt><dd><ul class="simple">
<li><p>Encoded as a …xDxD tensor (D=3 for 3D rotations).</p></li>
<li><p>We use column-vector convention, i.e. <span class="math notranslate nohighlight">\(R X\)</span> is the transformation of a 1xD vector <span class="math notranslate nohighlight">\(X\)</span>  by a rotation matrix <span class="math notranslate nohighlight">\(R\)</span>.</p></li>
</ul>
</dd>
<dt>Euler and Tait-Bryan angles are <em>NOT</em> currently supported.</dt><dd><p>This is because of the many different existing conventions, and because of the limited interest of such parameterization for numerical applications.</p>
</dd>
</dl>
</div>
<div class="section" id="mappings-between-rotation-representations">
<h2><a class="toc-backref" href="#id6">Mappings between rotation representations</a><a class="headerlink" href="#mappings-between-rotation-representations" title="Permalink to this headline">¶</a></h2>
<p><em>RoMa</em> provides functions to convert between rotation representations.</p>
<p>Example mapping a batch of rotation vectors into corresponding unit quaternions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">batch_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">rotvec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_unitquat</span><span class="p">(</span><span class="n">rotvec</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="mappings-from-euclidean-to-3d-rotation-space">
<h2><a class="toc-backref" href="#id7">Mappings from Euclidean to 3D rotation space</a><a class="headerlink" href="#mappings-from-euclidean-to-3d-rotation-space" title="Permalink to this headline">¶</a></h2>
<p>Mapping an arbitrary tensor to a valid rotation can be useful <em>e.g.</em> for Machine Learning applications.
While rotation vectors or Euler angles can be used for such purpose, they suffer from various shortcomings, and we therefore provide the following alternative mappings:</p>
<dl class="simple">
<dt><a class="reference internal" href="#roma.mappings.special_gramschmidt" title="roma.mappings.special_gramschmidt"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_gramschmidt()</span></code></a></dt><dd><p>Mapping from a 3x2 tensor to 3x3 rotation matrix, using special Gram-Schmidt orthonormalization (<em>6D</em> representation, popularized by <a class="reference external" href="https://arxiv.org/abs/1812.07035">Zhou et al.</a>).</p>
</dd>
<dt><a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a></dt><dd><p>Mapping from a nxn arbitrary matrix to a nxn rotation matrix, using special orthogonal Procrustes orthonormalization.</p>
</dd>
<dt><a class="reference internal" href="#roma.mappings.symmatrixvec_to_unitquat" title="roma.mappings.symmatrixvec_to_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">symmatrixvec_to_unitquat()</span></code></a></dt><dd><p>Mapping from a 10D vector to an antipodal pair of quaternion through eigenvector decomposition of a 4x4 symmetric matrix, proposed by <a class="reference external" href="https://arxiv.org/abs/2006.01031">Peretroukhin et al.</a>.</p>
</dd>
</dl>
<p>For general purpose applications, we recommend the use of <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> which projects an arbitrary square matrix onto the closest matrix of the rotation space,
considering Frobenius norm. Please refer to this <a class="reference external" href="https://arxiv.org/abs/2103.16317">paper</a> for more insights.</p>
<p>Example mapping random 3x3 matrices to valid rotation matrices:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">batch_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">special_procrustes</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">roma</span><span class="o">.</span><span class="n">is_rotation_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="support-for-an-arbitrary-number-of-batch-dimensions">
<h2><a class="toc-backref" href="#id8">Support for an arbitrary number of batch dimensions</a><a class="headerlink" href="#support-for-an-arbitrary-number-of-batch-dimensions" title="Permalink to this headline">¶</a></h2>
<p>For convenience, functions accept an arbitrary number of batch dimensions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([3, 3])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([5, 3, 3])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([2, 5, 3, 3])</span>
</pre></div>
</div>
</div>
<div class="section" id="quaternion-operations">
<h2><a class="toc-backref" href="#id9">Quaternion operations</a><a class="headerlink" href="#quaternion-operations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># Random unnormalized quaternion</span>
<span class="n">qconv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">quat_conjugation</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># Quaternion conjugation</span>
<span class="n">qinv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">quat_inverse</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># Quaternion inverse</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">quat_product</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qinv</span><span class="p">))</span> <span class="c1"># -&gt; [0,0,0,1] identity quaternion</span>
</pre></div>
</div>
</div>
<div class="section" id="rotation-composition-and-inverse">
<h2><a class="toc-backref" href="#id10">Rotation composition and inverse</a><a class="headerlink" href="#rotation-composition-and-inverse" title="Permalink to this headline">¶</a></h2>
<p>Example using rotation vector representation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">rotvecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">roma</span><span class="o">.</span><span class="n">random_rotvec</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="c1"># Random rotation vectors</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_composition</span><span class="p">(</span><span class="n">rotvecs</span><span class="p">)</span> <span class="c1"># Composition of an arbitrary number of rotations</span>
<span class="n">rinv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_inverse</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># Rotation vector corresponding to the inverse rotation</span>
</pre></div>
</div>
</div>
<div class="section" id="rotation-metrics">
<h2><a class="toc-backref" href="#id11">Rotation metrics</a><a class="headerlink" href="#rotation-metrics" title="Permalink to this headline">¶</a></h2>
<p><em>RoMa</em> implements some usual similarity measures over the 3D rotation space:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotmat_geodesic_distance</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">)</span> <span class="c1"># In radian</span>
<span class="n">cos_theta</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotmat_cosine_angle</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">R2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="weighted-rotation-averaging">
<h2><a class="toc-backref" href="#id12">Weighted rotation averaging</a><a class="headerlink" href="#weighted-rotation-averaging" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> can be used to easily average rotations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">R_i</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Batch of n 3x3 rotation matrices to average</span>
<span class="n">w_i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Weight of each matrix, between 0 and 1</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_i</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_i</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 3x3 matrix</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">special_procrustes</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="c1"># weighted average.</span>
</pre></div>
</div>
<p>To be precise, it consists in the Fréchet mean considering the chordal distance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same average could be performed using quaternion representation and <em>symmatrix</em> mapping (slower batched implementation on GPU).</p>
</div>
</div>
<div class="section" id="spherical-linear-interpolation-slerp">
<h2><a class="toc-backref" href="#id13">Spherical linear interpolation (SLERP)</a><a class="headerlink" href="#spherical-linear-interpolation-slerp" title="Permalink to this headline">¶</a></h2>
<p>SLERP between batches of unit quaternions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">q0</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">q_interpolated</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">unitquat_slerp</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
<span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Print interpolations for an arbitrary element of the batch</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q0:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q0</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q1:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q1</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q_interpolated:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q_interpolated</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
</pre></div>
</div>
<p>SLERP between rotation vectors (shortest path interpolation):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">roma</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">rotvec0</span><span class="p">,</span> <span class="n">rotvec1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">rotvec_interpolated</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_slerp</span><span class="p">(</span><span class="n">rotvec0</span><span class="p">,</span> <span class="n">rotvec1</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="why-a-new-library">
<h1><a class="toc-backref" href="#id14">Why a new library?</a><a class="headerlink" href="#why-a-new-library" title="Permalink to this headline">¶</a></h1>
<dl>
<dt>We could not find a PyTorch library satisfying our needs, so we built our own.</dt><dd><p>We wanted a reliable, easy-to-use and efficient toolbox to deal with rotation representations in PyTorch.
While Kornia provides some utility functions to deal with 3D rotations, it included several major bugs at the time of writting (early 2021) (see e.g. <a class="reference external" href="https://github.com/kornia/kornia/issues/723">https://github.com/kornia/kornia/issues/723</a> or <a class="reference external" href="https://github.com/kornia/kornia/issues/317">https://github.com/kornia/kornia/issues/317</a>).</p>
</dd>
<dt>Care for numerical precision</dt><dd><p><em>RoMa</em> is implemented with numerical precision in mind, e.g. with a special handling of small angle rotation vectors
or through the choice of appropriate algorithms.</p>
<p>As an example, below is plotted a function that takes as input an angle <span class="math notranslate nohighlight">\(\theta\)</span>,
produces a rotation matrix <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> of angle <span class="math notranslate nohighlight">\(\theta\)</span> and estimates its geodesic distance with respect to the identity matrix, using 32 bits floating point arithmetic.
We observe that <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance" title="roma.utils.rotmat_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a> is much more precise for this task than an other implementation
often found in academic code: <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a>.
Backward pass through <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a> leads to unstable gradient estimations and produces <em>Not-a-Number</em> values for small angles,
whereas <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a> is well-behaved, and returns <em>Not-a-Number</em> only for 0.0 angle where gradient is mathematically undefined.</p>
<img alt="_images/rotmat_geodesic_distance_zero.svg" src="_images/rotmat_geodesic_distance_zero.svg" /><img alt="_images/rotmat_geodesic_distance_grads_zero.svg" src="_images/rotmat_geodesic_distance_grads_zero.svg" /></dd>
<dt>Computation efficiency</dt><dd><p><em>RoMa</em> favors code clarity, but aims to be reasonably efficient.
In particular, for Procrustes orthonormalization it can use on NVidia GPUs a batched SVD decomposition
that provides orders of magnitude speed-ups for large batch sizes compared to vanilla <code class="docutils literal notranslate"><span class="pre">torch.svd()</span></code>
(tested with random 3x3 matrices, PyTorch 1.7, a NVidia Tesla T4 GPU and CUDA 11.0).</p>
<img alt="_images/special_procrustes_benchmark.svg" src="_images/special_procrustes_benchmark.svg" /></dd>
<dt>Syntactic sugar</dt><dd><p><em>RoMa</em> aims to be easy-to-use with a simple syntax, and supports of an arbitrary number of batch dimensions to let its users focus on their applications.</p>
</dd>
</dl>
</div>
<div class="section" id="api-documentation">
<h1><a class="toc-backref" href="#id15">API Documentation</a><a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-roma.mappings">
<span id="mappings"></span><h2><a class="toc-backref" href="#id16">Mappings</a><a class="headerlink" href="#module-roma.mappings" title="Permalink to this headline">¶</a></h2>
<p>Various mappings between different rotation representations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.procrustes">
<span class="sig-name descname"><span class="pre">procrustes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orthonormal matrix <span class="math notranslate nohighlight">\(R\)</span> minimizing Frobenius norm <span class="math notranslate nohighlight">\(\| M - R \|_F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>xNxN tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>force_rotation</strong> (<em>bool</em>) – if True, forces the output to be a rotation matrix.</p></li>
<li><p><strong>gradient_eps</strong> (<em>float &gt; 0</em>) – small value used to enforce numerical stability during backpropagation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of orthonormal matrices (…xNxN tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.procrustes_naive">
<span class="sig-name descname"><span class="pre">procrustes_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_rotation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.procrustes_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a> relying on default backward pass of autograd and SVD decomposition.
Could be slightly less stable than <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotmat_to_rotvec">
<span class="sig-name descname"><span class="pre">rotmat_to_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotmat_to_rotvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts rotation matrix to rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotmat_to_unitquat">
<span class="sig-name descname"><span class="pre">rotmat_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotmat_to_unitquat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts rotation matrix to unit quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotvec_to_rotmat">
<span class="sig-name descname"><span class="pre">rotvec_to_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">torch.Tensor</span><a class="headerlink" href="#roma.mappings.rotvec_to_rotmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts rotation vector to rotation matrix representation.
Conversion uses Rodrigues formula in general, and a first order approximation for small angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – small angle threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotvec_to_unitquat">
<span class="sig-name descname"><span class="pre">rotvec_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotvec_to_unitquat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts rotation vector into unit quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_gramschmidt">
<span class="sig-name descname"><span class="pre">special_gramschmidt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_gramschmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x3 rotation matrix obtained by Gram-Schmidt orthonormalization of two 3D input vectors (first two columns of input matrix M).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>x3xN tensor</em>) – batch of 3xN matrices, with N &gt;= 2.
Only the first two columns of the matrices are used for orthonormalization.</p></li>
<li><p><strong>epsilon</strong> (<em>float &gt;= 0</em>) – optional clamping value to avoid returning <em>Not-a-Number</em> values in case of ill-defined input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In case of ill-defined input (colinear input column vectors), the output will not be a rotation matrix.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_procrustes">
<span class="sig-name descname"><span class="pre">special_procrustes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <span class="math notranslate nohighlight">\(R\)</span> minimizing Frobenius norm <span class="math notranslate nohighlight">\(\| M - R \|_F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>xNxN tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>gradient_eps</strong> (<em>float &gt; 0</em>) – small value used to enforce numerical stability during backpropagation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (…xNxN tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_procrustes_naive">
<span class="sig-name descname"><span class="pre">special_procrustes_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_procrustes_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> relying on default backward pass of autograd and SVD decomposition.
Could be slightly less stable than <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.symmatrix_to_projective_point">
<span class="sig-name descname"><span class="pre">symmatrix_to_projective_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.symmatrix_to_projective_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a DxD symmetric matrix A into a projective point represented by a unit vector <span class="math notranslate nohighlight">\(q\)</span> minimizing <span class="math notranslate nohighlight">\(q^T A q\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>...</em><em>xDxD tensor</em>) – batch of symmetric matrices. Only the lower triangular part is considered.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of unit vectors <span class="math notranslate nohighlight">\(q\)</span> (…xD tensor).</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><ol class="upperalpha simple" start="22">
<li><p>Peretroukhin, M. Giamou, D. M. Rosen, W. N. Greene, N. Roy, and J. Kelly, “A Smooth Representation of Belief over SO(3) for Deep Rotation Learning with Uncertainty,” 2020, doi: 10.15607/RSS.2020.XVI.007.</p></li>
</ol>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>This mapping is unstable when the smallest eigenvalue of A has a multiplicity strictly greater than 1.</p></li>
<li><p>Current implementation is rather slow due to the implementation of <code class="docutils literal notranslate"><span class="pre">torch.symeig</span></code>.
CuSolver library provides a faster eigenvalue decomposition alternative, but results where found to be unreliable.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.symmatrixvec_to_unitquat">
<span class="sig-name descname"><span class="pre">symmatrixvec_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.symmatrixvec_to_unitquat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a 10D vector into a unit quaternion representation.
Based on <a class="reference internal" href="#roma.mappings.symmatrix_to_projective_point" title="roma.mappings.symmatrix_to_projective_point"><code class="xref py py-func docutils literal notranslate"><span class="pre">symmatrix_to_projective_point()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>...</em><em>x10 tensor</em>) – batch of 10D vectors.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><ol class="upperalpha simple" start="22">
<li><p>Peretroukhin, M. Giamou, D. M. Rosen, W. N. Greene, N. Roy, and J. Kelly, “A Smooth Representation of Belief over SO(3) for Deep Rotation Learning with Uncertainty,” 2020, doi: 10.15607/RSS.2020.XVI.007.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.unitquat_to_rotmat">
<span class="sig-name descname"><span class="pre">unitquat_to_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.unitquat_to_rotmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts unit quaternion into rotation matrix representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.
No normalization is applied before computation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.unitquat_to_rotvec">
<span class="sig-name descname"><span class="pre">unitquat_to_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.unitquat_to_rotvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts unit quaternion into rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.
No normalization is applied before computation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-roma.utils">
<span id="utils"></span><h2><a class="toc-backref" href="#id17">Utils</a><a class="headerlink" href="#module-roma.utils" title="Permalink to this headline">¶</a></h2>
<p>Various utility functions related to rotation representations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.is_orthonormal_matrix">
<span class="sig-name descname"><span class="pre">is_orthonormal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.is_orthonormal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if matrices are orthonormal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>...</em><em>xDxD tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>epsilon</strong> – tolerance threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boolean tensor (shape …).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.is_rotation_matrix">
<span class="sig-name descname"><span class="pre">is_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.is_rotation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if matrices are rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>...</em><em>xDxD tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>epsilon</strong> – tolerance threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boolean tensor (shape …).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_composition">
<span class="sig-name descname"><span class="pre">quat_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the product of a sequence of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence of </em><em>...</em><em>x4 tensors</em><em>, </em><em>XYZW convention</em>) – sequence of batches of quaternions.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – it True, normalize the returned quaternion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_conjugation">
<span class="sig-name descname"><span class="pre">quat_conjugation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_conjugation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the conjugation of input batch of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Conjugation of a unit quaternion is equal to its inverse.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_inverse">
<span class="sig-name descname"><span class="pre">quat_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inverse of a batch of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Inverse of null quaternion is undefined.</p></li>
<li><p>For unit quaternions, consider using conjugation instead.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_product">
<span class="sig-name descname"><span class="pre">quat_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the product of two quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p></li>
<li><p><strong>q</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_rotmat">
<span class="sig-name descname"><span class="pre">random_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_rotmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a batch of random 3x3 rotation matrices, uniformly sampled according to the usual rotation metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (size x 3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_rotvec">
<span class="sig-name descname"><span class="pre">random_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_rotvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a batch of random rotation vectors, uniformly sampled according to the usual rotation metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation vectors (size x 3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_unitquat">
<span class="sig-name descname"><span class="pre">random_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_unitquat" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a batch of random unit quaternions, uniformly sampled according to the usual quaternion metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of unit quaternions (size x 4 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_composition">
<span class="sig-name descname"><span class="pre">rotmat_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the product of a sequence of rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence of </em><em>...</em><em>xNxN tensors</em>) – sequence of batches of rotation matrices.</p></li>
<li><p><strong>normalize</strong> – if True, apply special Procrustes orthonormalization to compensate for numerical errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation matrices (…xNxN tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_cosine_angle">
<span class="sig-name descname"><span class="pre">rotmat_cosine_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_cosine_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cosine angle of the input 3x3 rotation matrix R.
Based on the equality <span class="math notranslate nohighlight">\(Trace(R) = 1 + 2 cos(alpha)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3w3 rotation matrices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of cosine angles (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_geodesic_distance">
<span class="sig-name descname"><span class="pre">rotmat_geodesic_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_geodesic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angular distance alpha between a pair of rotation matrices.
Based on the equality <span class="math notranslate nohighlight">\(|R_2 - R_1|_F = 2 \sqrt{2} sin(alpha/2)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R1</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
<li><p><strong>R2</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of angles in radian (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_geodesic_distance_naive">
<span class="sig-name descname"><span class="pre">rotmat_geodesic_distance_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_geodesic_distance_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angular distance between a pair of rotation matrices.
Based on <a class="reference internal" href="#roma.utils.rotmat_cosine_angle" title="roma.utils.rotmat_cosine_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_cosine_angle()</span></code></a> and less precise than <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance" title="roma.utils.rotmat_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a> for nearby rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R1</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
<li><p><strong>R2</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of angles in radian (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_inverse">
<span class="sig-name descname"><span class="pre">rotmat_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inverse of a rotation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>xNxN tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of inverted rotation matrices (…xNxN tensor).</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The function returns a transposed view of the input, therefore one should be careful with in-place operations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_composition">
<span class="sig-name descname"><span class="pre">rotvec_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotation vector corresponding to the composition of a sequence of rotations represented by rotation vectors.
Composition is performed using an intermediary quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence of </em><em>...</em><em>x3 tensors</em>) – sequence of batches of rotation vectors.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – if True, normalize intermediary representation to compensate for numerical errors.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_inverse">
<span class="sig-name descname"><span class="pre">rotvec_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inverse of the input rotation expressed using rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_slerp">
<span class="sig-name descname"><span class="pre">rotvec_slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotvec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_slerp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical linear interpolation between two rotation vector representations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotvec0</strong> (<em>Ax3 tensor</em>) – batch of rotation vectors (A may contain multiple dimensions).</p></li>
<li><p><strong>rotvec1</strong> (<em>Ax3 tensor</em>) – batch of rotation vectors (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor of shape B</em>) – interpolation steps, 0.0 corresponding to rotvec0 and 1.0 to rotvec1 (B may contain multiple dimensions).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of interpolated rotation vectors (BxAx3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.unitquat_slerp">
<span class="sig-name descname"><span class="pre">unitquat_slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.unitquat_slerp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical linear interpolation between two unit quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q0</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>q1</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor of shape B</em>) – interpolation steps, 0.0 corresponding to q0 and 1.0 to q1 (B may contain multiple dimensions).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>batch of interpolated quaternions (BxAx4 tensor).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When considering quaternions as rotation representations,
one should keep in mind that interpolation is not necessarily performed along the shortest arc,
depending on the sign of <code class="docutils literal notranslate"><span class="pre">torch.sum(q0*q1,dim=-1)</span></code>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="advanced">
<h1><a class="toc-backref" href="#id18">Advanced</a><a class="headerlink" href="#advanced" title="Permalink to this headline">¶</a></h1>
<div class="section" id="running-unit-tests">
<h2><a class="toc-backref" href="#id19">Running unit tests</a><a class="headerlink" href="#running-unit-tests" title="Permalink to this headline">¶</a></h2>
<p>from source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
</div>
<div class="section" id="building-sphinx-documentation">
<h2><a class="toc-backref" href="#id20">Building Sphinx documentation</a><a class="headerlink" href="#building-sphinx-documentation" title="Permalink to this headline">¶</a></h2>
<p>From source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">build_doc</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="license">
<h1><a class="toc-backref" href="#id21">License</a><a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h1>
<p><em>RoMa</em>, Copyright (c) 2021 NAVER Corp., is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 license (see <a class="reference external" href="https://github.com/naver/roma/blob/master/LICENSE">license</a>).</p>
<p>Bits of code were adapted from SciPy. Documentation is generated, distributed and displayed with the support of Sphinx and other materials (see <a class="reference external" href="https://github.com/naver/roma/blob/master/NOTICE">notice</a>).</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<p>For a more in-depth discussion regarding differentiable mappings on the rotation space, please refer to:</p>
<p><strong>Romain Brégier, Deep regression on manifolds: a 3D rotation case study.</strong> Technical report arXiv 2103.16317, 2021. (<a class="reference external" href="https://arxiv.org/abs/2103.16317">https://arxiv.org/abs/2103.16317</a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@article</span><span class="p">{</span><span class="n">bregier2021deep</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="p">{</span><span class="n">Deep</span> <span class="n">regression</span> <span class="n">on</span> <span class="n">manifolds</span><span class="p">:</span> <span class="n">a</span> <span class="p">{</span><span class="mi">3</span><span class="n">D</span><span class="p">}</span> <span class="n">rotation</span> <span class="n">case</span> <span class="n">study</span><span class="p">},</span>
    <span class="n">author</span><span class="o">=</span><span class="p">{</span><span class="n">Br</span><span class="p">{</span>\<span class="s1">&#39;e}gier, Romain},</span>
    <span class="n">journal</span><span class="o">=</span><span class="p">{</span><span class="n">arXiv</span> <span class="n">preprint</span> <span class="n">arXiv</span><span class="p">:</span><span class="mf">2103.16317</span><span class="p">},</span>
    <span class="n">year</span><span class="o">=</span><span class="p">{</span><span class="mi">2021</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For <em>RoMa</em>-related inquiries, feel free to get in touch using GitHub issues.</p>
</div>
<div class="section" id="changelog">
<h1><a class="toc-backref" href="#id23">Changelog</a><a class="headerlink" href="#changelog" title="Permalink to this headline">¶</a></h1>
<dl class="simple">
<dt>Version 1.2.0:</dt><dd><p>Open-source release.</p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Naver Corp..

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>